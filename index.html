<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AR Menu</title>

<style>
  body { margin:0; overflow:hidden; }
  #hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 10px 16px;
    border-radius: 20px;
    font-family: sans-serif;
    font-size: 14px;
  }
</style>
</head>

<body>

<div id="hint">وجّه الكاميرا على الطاولة واضغط لوضع الطبق</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer;
let reticle;
let dish;

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  document.body.appendChild(ARButton.createButton(renderer, {
    requiredFeatures: ['hit-test']
  }));

  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  scene.add(light);

  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI / 2),
    new THREE.MeshBasicMaterial()
  );
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  const urlParams = new URLSearchParams(window.location.search);
  const dishName = urlParams.get('dish') || 'pizza.png';

  const texture = new THREE.TextureLoader().load('images/' + dishName);
  const geometry = new THREE.PlaneGeometry(0.4, 0.4);
  const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
  dish = new THREE.Mesh(geometry, material);
  dish.rotation.x = -Math.PI / 2;

  renderer.domElement.addEventListener('click', () => {
    if (reticle.visible) {
      dish.position.setFromMatrixPosition(reticle.matrix);
      scene.add(dish);
      document.getElementById('hint').style.display = 'none';
    }
  });
}

function animate() {
  renderer.setAnimationLoop(render);
}

function render(timestamp, frame) {
  if (frame) {
    const referenceSpace = renderer.xr.getReferenceSpace();
    const session = renderer.xr.getSession();

    if (!renderer.hitTestSourceRequested) {
      session.requestReferenceSpace('viewer').then(space => {
        session.requestHitTestSource({ space }).then(source => {
          renderer.hitTestSource = source;
        });
      });
      renderer.hitTestSourceRequested = true;
    }

    if (renderer.hitTestSource) {
      const hitTestResults = frame.getHitTestResults(renderer.hitTestSource);
      if (hitTestResults.length) {
        const hit = hitTestResults[0];
        reticle.visible = true;
        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
      } else {
        reticle.visible = false;
      }
    }
  }
  renderer.render(scene, camera);
}
</script>

</body>
</html>
